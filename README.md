# Frontend Project

## Description

NextJS Frontend Project for [pay.getshield.xyz/](https://pay.getshield.xyz/)

## Project Structure

```
.next/
.vscode/
node_modules
public/
src/
   actions/
   app/
      (route-group)/route/page.jsx
      api/
      error.jsx
      favicon.ico
      globals.css
      layout.jsx
      page.jsx
   assets/
   components/
   config/
   features/
   hooks/
   lib/
   services/
   middleware
.eslintrc.js
.gitignore
.prettierrc.js
components.json
jsconfig.json
next-env.d.ts
next.config.mjs
package-lock.json
package.json
postcss.config.mjs
README.md
tailwind.config.js
```

### Folder and File Description

- **.next/**: A directory generated by Next.js during the build process. It contains the output of the compiled pages and modules, optimized for production.

- **.vscode/**: This directory **stores** configurations specific to Visual Studio Code, such as settings for the editor, extensions, and debugging configurations.

- **node_modules/**: Contains all the npm packages and their dependencies that the project relies on. These are installed via `npm install` or `yarn`.

- **public/**: A folder for static files like images, `favicon.ico`, and any other assets that can be accessed directly without being processed by Next.js.

- **src/**: The source directory where the main application code resides. It's further organized into subdirectories:

  - **actions/**: global server actions which objective is just a convenient way to mutate data without having to create an API
  - **app/**: Contains the core application logic, including specific features or pages like authentication, payment link creation, dashboard, etc.
    - **api/**: Dedicated to API calls or endpoints if using Next.js API routes.
    - **error.jsx**: A React component for error handling.
    - **favicon.ico**: The favicon for the web application, typically displayed in the browser tab.
    - **globals.css**: Global CSS styles that apply throughout the application.
    - **layout.jsx**: A React component for the main layout of the application.
    - **page.jsx**: Could be a template or a specific page component.
  - **assets/**: For additional static assets like images, fonts, etc., that need to be imported into the project through JavaScript or CSS.
  - **components/**: Reusable React components.
  - **config/**: Configuration files for the application, possibly including environment variables or settings.
  - **features/**: Organized code modules for specific features of the application.
    - Inside features, we create folders for every feature of the application we want to specify. Inside each feature we create different folders as /components, /actions, /utils, /hooks, etc.
  - **hooks/**: Custom React hooks.
  - **lib/**: Library code or utility functions.
  - **services/**: Services for external API calls or business logic.
  - **middleware**: Middleware functions for handling requests or augmenting the application's behavior.

- **.eslintrc.js**: Configuration file for ESLint, a tool for identifying and reporting on patterns found in ECMAScript/JavaScript code.

- **.gitignore**: Specifies intentionally untracked files to ignore.

- **.prettierrc.js**: Configuration file for Prettier, a code formatter.

- **components.json**: File created and used by the ShadCN UI library

- **jsconfig.json**: Helps Visual Studio Code to provide IntelliSense for JavaScript projects.

- **next-env.d.ts**: TypeScript declaration file generated by Next.js, enabling TypeScript support.

- **next.config.mjs**: Configuration file for Next.js, possibly including custom settings like environment variables, page extensions, etc.

- **package-lock.json**: Automatically generated file for any operations where npm modifies either the node_modules tree or package.json.

- **package.json**: Holds metadata relevant to the project and it is used for managing the project's dependencies, scripts, and versions.

- **postcss.config.mjs**: Configuration file for PostCSS, a tool for transforming CSS with JavaScript.

- **README.md**: A markdown file containing information about the project, such as setup instructions, project description, and usage.

- **tailwind.config.js**: Configuration file for Tailwind CSS, a utility-first CSS framework for rapidly building custom designs.

## Installation

1. Clone the repository `git clone https://github.com/shield-xyz/paymentLinkFrontend`
2. Navigate into the project directory: `cd paymentLinkFrontend`
3. Install the necessary dependencies by running: `.env`
4. Configure the environment: Create a `.env` file based on `.env.example`

## Use

- To run the project, use the following command: `npm run dev`
- To build the project for production, use the following commands: `npm run build` -> `npm run start`

## Tech Stack

- Next.js
- Node.js
- JavaScript
- TailwindCSS (CSS)
- Next-Auth
- Zod (Form validations)
- React Hook Form (Forms)
- ShadCN (UI)
- Recharts (Charts)
- Sonner (toasters)

## Authentication - Next-Auth

- Next auth is a secure library that uses token validation, tab syncing, auto-revalidation and more.
- Its main logic is under the folder /lib/auth and passes the authOptions to the /api/auth/[...nextauth] file.
- It uses a SessionProvider which is inside the /lib/Provider.jsx file.

## Routing with NextJS

- Pages are created by NextJs inside the app/ folder.
- Folders created with `()` are called route groups. Encapsulates without adding a route (this is useful for adding a specific layout for a group of pages)
- Folders without `()` create a specific route, for example [paylink] creates the page /paylink
- Every page should have the name page.jsx
- Layouts are used to add styles and logic for the children.
- Dynamic routes are used with brackets `[]`, for example paylink/[paylinkId] is a route for paylink/1, paylink/123, paylink/954
- The api/ folder is used for creating an API under the route /api. We are using a separated backend for this project but we need the auth folder because of Next-Auth

## The Features Folder

- **Modular** Structure: Each feature is encapsulated within its own folder. This encapsulation includes all the necessary components, services, hooks, state management, and utilities required to implement the feature. This modular approach makes the codebase more manageable, scalable, and easier to understand.
- **Isolation**: By isolating features into separate folders, developers can work on one feature without the risk of inadvertently affecting another. This isolation also simplifies debugging and testing, as each feature can be tested in isolation.
- **Reusability**: Components and utilities within a feature can be designed to be reusable across other features within the application, promoting DRY (Don't Repeat Yourself) principles.
- **Scalability**: As the application grows, new features can be added as new folders. This scalability ensures that the application can evolve without significant restructuring.
